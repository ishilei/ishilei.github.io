<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>地球太冷</title><link>http://www.ishilei.com/</link><description></description><atom:link href="http://www.ishilei.com/feeds/shi-pin-chuan-shu.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 05 Nov 2014 15:10:00 +0800</lastBuildDate><item><title>H.264的零散笔记整理</title><link>http://www.ishilei.com/pages/2014/11/05/ctreat4.html</link><description>&lt;h4&gt;H264与ffmpeg&lt;/h4&gt;
&lt;p&gt;简单地说，H.264是一种编码协议，而ffmpeg则是含有支持H.264编码程序的程序包。H.264压缩比非常高，所以是目前音视频压缩的主流算法。现在已经有了H.265压缩算法，理论上在相同的带宽下可以传输两倍的数据量，并且已经有了不少成熟的产品开始投入使用。&lt;/p&gt;
&lt;h4&gt;H.264中帧，场，宏块等数据单位&lt;/h4&gt;
&lt;p&gt;一帧，即一副静止的图像，可分为两场（奇数场和偶数场）。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;或者说一个视频图像编码后的数据叫做一帧（frame）&lt;br /&gt;
一帧有一个片或者多个片（slice）组成&lt;br /&gt;
一个片由一个或多个宏块（MB）组成&lt;br /&gt;
一个宏块由16×16的YUV数据组成&lt;/p&gt;
&lt;h6&gt;视频编码算法以宏块为单位，逐个编码，组成连续视频流&lt;/h6&gt;
&lt;p&gt;帧又可以分为：I帧，P帧，B帧&lt;br /&gt;
I帧： 也叫做关键帧，包含完整的画面信息&lt;br /&gt;
P帧：前向预测帧，只存储与前一个已解压帧的差值&lt;br /&gt;
B帧：双向预测帧，同时依赖前一个帧和后一个帧的编解码&lt;/p&gt;
&lt;h6&gt;VCL和NAL相关概念&lt;/h6&gt;
&lt;p&gt;H.264的算法在概念上可以分为两层：VCL（视频编码层）负责视频内容的表示，NAL（网络提取层）负责以网络所要求的恰当的方式对数据进行打包和传送。&lt;br /&gt;
NAL以NALU(NAL Unit)为单位来支持编码数据在基于分组交换技术网络中传输。&lt;br /&gt;
VCL层，最原始的编码数据（SODB）经过编码，在后加若干结尾比特（字节对齐）——&amp;gt;&amp;gt;&amp;gt;RBSP&lt;br /&gt;
&lt;strong&gt;NALU===NAL(NAL头信息)+RBSP（原始字节序列载荷）&lt;/strong&gt;&lt;br /&gt;
注意：并不是一帧对应于一个NALU，一个slice封装成一个nal，一帧可以有多个slice，所以一帧有多个nal &lt;/p&gt;
&lt;h4&gt;视频传输过程中的参数&lt;/h4&gt;
&lt;p&gt;GOP：根据定义GOP表示两个I帧之间帧的数量，默认情况下 帧率和GOP长度相同。
比如帧序列 IPPPPI 的GOP长度即为5。&lt;br /&gt;
在保持相同的帧速率下，可以提高GOP的值实现降低码流(更多中小P帧和较少的大尺寸I帧)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;码流，也叫码率，或者比特率。视频中的码流指由模拟信号转换为数字信号的采样率。&lt;br /&gt;
码流越大，需要占用的带宽也越大。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;帧率，指每秒钟刷新图片的帧数。&lt;/p&gt;
&lt;h6&gt;帧率：影响视频的连贯性　　　　 码率：影响视频的图像质量&lt;/h6&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">shilei</dc:creator><pubDate>Wed, 05 Nov 2014 15:10:00 +0800</pubDate><guid>tag:www.ishilei.com,2014-11-05:pages/2014/11/05/ctreat4.html</guid><category>project</category></item><item><title>RTP相关笔记</title><link>http://www.ishilei.com/pages/2014/11/05/ctreat3.html</link><description>&lt;h4&gt;为什么采用RTP而不直接利用UDP发送数据&lt;/h4&gt;
&lt;p&gt;UDP无法加载流的时间信息，而RTP可以提供时间信息并且实现流同步。&lt;/p&gt;
&lt;h4&gt;H.264 RTP 负载格式&lt;/h4&gt;
&lt;h6&gt;&lt;font color='green'&gt;NALU&lt;/font&gt;&lt;/h6&gt;
&lt;p&gt;NALU头由一个字节组成&lt;br /&gt;
+-------------------------------+&lt;br /&gt;
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |&lt;br /&gt;
| F | NRI   | 　　TYpe 　|　　&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;F : 在Ｈ.264中规定必须置为1&lt;br /&gt;
NRI : 知道NALU重要性，一般情况不关心&lt;br /&gt;
Type：指示这个NALU单元的类型。&lt;br /&gt;
NALU使用RTP包进行发送的可能类型有三种，都由Type字段相应的值进行指定。&lt;br /&gt;
1. 单一NAL单元模式，即一个RTP包仅由一个完整的NALU组成。
2. 组合封包模式，即可能由多个NAL单元组成一个RTP包。
3. 分片封包模式，用与把 一个NALU单元封装成多个RTP包。&lt;/p&gt;
&lt;h6&gt;在我的使用中，只遇到了第一种和第三种类型&lt;/h6&gt;
&lt;h6&gt;&lt;font color='green'&gt;单一NALU发送&lt;/font&gt;&lt;/h6&gt;
&lt;p&gt;NALU长度小于MTU大小的包，一般采用这种发送方式。&lt;br /&gt;
&lt;strong&gt;NALU=StartCode + NALU Header + NALU Payload&lt;/strong&gt;&lt;br /&gt;
StartCode : 用于标志一个NALU单元的开始，必须是“00 00 00 01”或“00 00 01”&lt;br /&gt;
NALU Header ： 一个字节，NALU头&lt;br /&gt;
NALU Payload : NALU负载内容  &lt;/p&gt;
&lt;h6&gt;RTP打包时，去除StartCode,把剩下的数据封包成RTP包即可&lt;/h6&gt;
&lt;p&gt;例如一个NALU数据是下面所示：&lt;br /&gt;
【00 00 00 01 67 42 78 A0 E4 65…… 】&lt;br /&gt;
封装成RTP包，即如下所示：&lt;br /&gt;
【RTPHeader | 67 42 78 A0 E4 65 ……】  &lt;/p&gt;
&lt;h6&gt;客户端是播放器，如VLC，则需要将StartCode去除，而如果使用ffmpeg在客户端解码，则发送前不需要去除StartCode。&lt;/h6&gt;
&lt;h6&gt;&lt;font color='green'&gt;FU-A的分片格式&lt;/font&gt;&lt;/h6&gt;
&lt;p&gt;NALU长度大于MTU的包，需要分片发送。12字节的RTP Header后面跟着就是FU-A分片。&lt;br /&gt;
FU-A分片时FU indicator中type字段等于28。  &lt;/p&gt;
&lt;h6&gt;注：很多资料中既有NALU indicator和NALU Header两种写法，令人困惑。在单一NALU中一般写成NALU Header，而在FU-A分片中一般写成NALU indicator。你可以认为在FU-A分片中，NALU header被拆分成了FU indicator 和Fu header。&lt;/h6&gt;
&lt;p&gt;采用FU-A分片，在NALU indicator 后面还有一个字节的FU header&lt;br /&gt;
FU header 的格式如下：&lt;br /&gt;
+-------------------------------+&lt;br /&gt;
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |&lt;br /&gt;
| S | E | R |  　Type　　|&lt;br /&gt;
+-------------------------------+&lt;br /&gt;
S bit： 表示分片NAL的开始，当它为1时，E不能为1&lt;br /&gt;
E bit ： 表示分片NAL的结束，当它为1是，S不能为1&lt;br /&gt;
R bit：保留位 
Type ： 就是NALU indicator中的Type&lt;br /&gt;
&lt;strong&gt;同一个NALU分包后的FU indicator是完全一致的，FU header只有S以及E位有区别，分别标记开始和结束，它们RTP分包的序列号应该是依次递增的，并且它们的时间戳必须一致。&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">shilei</dc:creator><pubDate>Wed, 05 Nov 2014 11:10:00 +0800</pubDate><guid>tag:www.ishilei.com,2014-11-05:pages/2014/11/05/ctreat3.html</guid><category>project</category></item><item><title>AdHocMonitor系统中关于视频部分的说明</title><link>http://www.ishilei.com/pages/2014/11/04/ctreat.html</link><description>&lt;h5&gt;一. 客户端相关cpp的简要说明&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=''&gt;main.cpp &lt;/font&gt;：其中包括字符格式的设置，QSplashSreen实现Qt程序的画面启动等。 &lt;/li&gt;
&lt;li&gt;common.h : 定义程序的通用信息，即一些宏定义。&lt;/li&gt;
&lt;li&gt;abstractconf.cpp : 设置类的基类。比如虚函数 &lt;code&gt;loadConf()&lt;/code&gt;,&lt;code&gt;saveConf()&lt;/code&gt;...&lt;/li&gt;
&lt;li&gt;Uiappabout : 显示程序关于信息，包括软件的作者学校等信息。&lt;/li&gt;
&lt;li&gt;Uiappoutput.cpp : 整个程序运行中相关信息的显示输出类&lt;/li&gt;
&lt;li&gt;Uidatasingle.cpp : 视频连接界面。有显示网络节点，新建及放弃连接等成员函数&lt;/li&gt;
&lt;li&gt;Uivideowindow.cpp : 视频渲染底板。本程序提供了6个视频显示窗口实现&lt;code&gt;addWin(),delWin()&lt;/code&gt;添加删除渲染空间。&lt;/li&gt;
&lt;li&gt;Uimainconf.cpp : 设置界面集合。&lt;code&gt;addConf()&lt;/code&gt;增加相关配置界面，此程序中目前有程序，路由，视频和扩展4个配置界面。&lt;code&gt;confUpdate()&lt;/code&gt;完成更新。&lt;code&gt;applyClicked()&lt;/code&gt;应用配置修改。还有一些其他相关配置参数的操作。&lt;/li&gt;
&lt;li&gt;Uivideocons.cpp : 视频连接列表界面组件。实现删除，清空列表。比如双击连接的IP地址，即可删除对应此IP的视频连接。&lt;/li&gt;
&lt;li&gt;Uivideoconf.cpp : 视频配置界面组件。其中包括一些端口的设置，刷新时间、确认时间、最大连接数、是否自动重连等参数的设置。&lt;/li&gt;
&lt;li&gt;Uivideorender.cpp : 视频画面渲染类。客户端将接收到的画面数据进行渲染，最终显示在屏幕上。&lt;/li&gt;
&lt;li&gt;Uivideosingle.cpp : 独立新建视频连接。添加选择节点&lt;code&gt;addNode()&lt;/code&gt;，双击处理单元 &lt;code&gt;nodeSelect()&lt;/code&gt;。以及新建独立视频连接的相关实现。&lt;/li&gt;
&lt;li&gt;Uivideowin.cpp : 单视频画面窗口。其中包括了解码、渲染等相关类。&lt;/li&gt;
&lt;li&gt;decodethread.cpp : 解码线程。&lt;/li&gt;
&lt;li&gt;videocom.cpp : 视频通讯控制类。获取视频配置界面的参数，并且通过&lt;code&gt;QUdpSocket&lt;/code&gt;类和远程端口建立连接，把当前客户端参数设置发送给服务器。&lt;/li&gt;
&lt;li&gt;videoconf.cpp : 继承了abstractconf类，并且实现了&lt;code&gt;loadConf()&lt;/code&gt;,&lt;code&gt;saveConf()&lt;/code&gt;等基类中的虚函数。&lt;/li&gt;
&lt;li&gt;videoins.cpp : 单视频连接。视频配置界面组件的参数获取（由用户自定义视频传输的参数）。&lt;/li&gt;
&lt;li&gt;videomain.cpp : 视频控制系统核心。其中包括了，各种组件的的获得，状态的变化&lt;code&gt;insStarted（）&lt;/code&gt;
 等signal以及视频的显示新建，启动、停止等slot。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;二. 服务器端相关cpp的简要说明&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Common.h :  变量及结构定义。其中包括控制参数结构体，客户端连接队列，客户端信息结构体，缓冲区以及各种视频参数变量的声明定义。&lt;/li&gt;
&lt;li&gt;H264.cpp : 摄像头的初始化&lt;code&gt;InitCarm()&lt;/code&gt;,RTP连接的初始化&lt;code&gt;InitRTPConPara()&lt;/code&gt;,以及数据压缩
API的调用。包括TS传输时，pmt，pat，pts，pcr等信息的写入。最后实现两种RTP/TS发送方式的&lt;code&gt;sendMainTS()&lt;/code&gt;和&lt;code&gt;sendMainRTP()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;H264server.cpp : 负责服务器端的监听。其中有初始化客户端连接队列，初始化连接参数，从配置文件读写取配置参数，接受客户端连接的请求，从客户端队列中移除某个客户端等具体操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;三.server端的主要运行流程&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Init_Para() //初始化传输参数&lt;/code&gt; 在h264.conf中调用&lt;code&gt;ReadConfigfile()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Init_ctrl_property() //初始化控制信息&lt;/code&gt;  即_control结构体，内有sysexit sendThread等成员；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Init_client_queue() //初始化客户端连接队列&lt;/code&gt; 即结构体_clientQ,内有RTPsession RTPsessionParams等成员；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comu_server_listen() //创建socket连接，申请serverMsgBuffer[]缓冲区接收客户端发送过来的消息&lt;/code&gt;  消息中包括消息类型如&lt;code&gt;SOC_CON2,SOC_RES，resolution,framerate,streamtype...&lt;/code&gt;然后把消息参数写如h264.conf配置文件中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h6&gt;接着需要判断刚接收到streamtype类型，如果streamtype=1，表示客户端希望TS传输方式，如果streamtype=2，则表示客户端希望RTP传输方式&lt;/h6&gt;
&lt;h6&gt;TS传输方式,主要步骤在&lt;code&gt;sendMainTS()&lt;/code&gt;函数中&lt;/h6&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_video_para&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="c1"&gt;//打印视频传输相关参数`  即从客户端接收的参数消息&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Init_Carm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//初始化摄像头 其中包括了帧缓冲区的申请，内存映射等操作，最后采集图像。  &lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetCamrFramNALU&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//得到一个NALU，这里实现时默认NALU即一个视频帧，其中还包括了MFC（Multi Fomat Codec,支持H.264的编解码）编码的三个函数，对一帧进行了压缩编码  &lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;retransmit_si_info&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;mpegts_insert_pcr_only&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//插入PMT，PAT表和PCR  &lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;prepare_packet_header&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//write PES header ,write pts dts  &lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//往客户端发送数据帧  TS_PACKET_SIZE ： 188字节&lt;/span&gt;

&lt;span class="cp"&gt;######RTP传输方式，主要步骤在`sendMainRTP()`函数中&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump_video_para&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//打印视频传输相关参数  &lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Init_Carm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InitRTPConPara&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;//初始化RTP连接 如增加请求连接的客户端地址  &lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetCamrFramNALU&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="err"&gt;和&lt;/span&gt;&lt;span class="n"&gt;TS&lt;/span&gt;&lt;span class="err"&gt;一样，通过&lt;/span&gt;&lt;span class="n"&gt;ioctl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;VIDIOC_DQBUF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;从缓冲区中取得&lt;/span&gt;        &lt;span class="err"&gt;一帧并进行压缩编码。&lt;/span&gt;  
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;根据帧的大小&lt;/span&gt; &lt;span class="n"&gt;payloadsize&lt;/span&gt; &lt;span class="err"&gt;判断是否需要分包。然后调用&lt;/span&gt; &lt;span class="n"&gt;RTP&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt; &lt;span class="n"&gt;sendPacket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;发送数据帧&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;四. client流程,主要说明DecodeThread.cpp&lt;/h5&gt;
&lt;h6&gt;判断videostreamtype的值&lt;/h6&gt;
&lt;h6&gt;videostreamtype==2&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;创建RTP会话，设置RTP参数&lt;/li&gt;
&lt;li&gt;注册所有容器格式和COEDC，包括avCodeCtx解码器上下文结构，其中包括视频 width,height等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avcodec_open() //打开解码器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session.BeginDataAccess() //开始接收数据&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看nalutype的值，判断是否分片传输的。如果是分片传输，则需要判断起始片和结束片。&lt;/li&gt;
&lt;li&gt;接收完整NALU后调用&lt;code&gt;avcodec_decode_video()&lt;/code&gt;解码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sws_getContext()&lt;/code&gt;进行图像转换，把YUV420P(亮度和色彩，节省带宽)转换成RGB32&lt;/li&gt;
&lt;/ol&gt;
&lt;h6&gt;videostreamtype==1&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;注册容器格式和CODEC &lt;code&gt;avcodec_init()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avFormatCtx-&amp;gt;streams[count]-&amp;gt;codec-&amp;gt;codec_type==CODEC_TYPE_VIDEO&lt;/code&gt;寻找视频流&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avcodec_open()&lt;/code&gt; 打开解码器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;av_read_frame()&lt;/code&gt; 从视频流中读取视频数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avcodec_decode_video2()&lt;/code&gt; 对视频数据进行解码&lt;/li&gt;
&lt;li&gt;进行图像转换&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">shilei</dc:creator><pubDate>Tue, 04 Nov 2014 20:10:00 +0800</pubDate><guid>tag:www.ishilei.com,2014-11-04:pages/2014/11/04/ctreat.html</guid><category>project</category></item></channel></rss>